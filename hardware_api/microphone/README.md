## マイクロフォンハードウェア API

録音デバイスを制御するハードウェア API

### 概要

Tumbler(T-01) に搭載された録音デバイスは、Linux の標準的なマイクデバイスではなく、独立したサブシステムとなっています。ALSA 等の標準的な枠組みをそのまま利用することはできませんが、その代替として、簡単な制御 API が定義されています。

### ハードウェア API リファレンス

#### API の概要

録音デバイスは、`/dev/ttyACM0` というキャラクタデバイスとして、本体 OS から見えています。このデバイスに録音開始・録音終了命令を送ることができ、このデバイスを fread() することで録音データを取得することが出来ます。

#### 録音の制御

##### 録音の開始

`/dev/ttyAMC0` に対してボーレート96kHzのシリアル通信で ASCII 文字の `1` を送信すると録音が開始されます。

##### 録音の終了

同、ASCII 文字の `0` を送信すると録音は終了されます。

##### 録音データの取得

`/dev/ttyAMC0` に対して、fopen(), fread(), fclose() の枠組みで、録音データを取得することができます。

### ハードウェア API 利用例

本ディレクトリに含まれる `rec.cpp` を御覧ください。同梱されている `Makefile` によって、Tumbler 上でビルドすることができます。以下に抜粋して説明を行います。

##### （１）録音デバイスを開く

``````````cpp
// 録音デバイスを開く
FILE *stream = fopen("/dev/ttyACM0","r");
``````````

録音デバイスは、Linux 上での通常のファイルのように開くことができます。

##### （２）録音デバイスに録音開始命令を送る

``````````cpp
// 録音デバイスに録音開始命令を送る
int control = serialOpen("/dev/ttyACM0",9600);
serialPutchar(control, '1'); // 録音開始命令
``````````

ボーレート 96kHz で同一のデバイスに対してシリアル通信を開き、`1` を送ります。ここでは、外部ライブラリの WiringPi を利用していますが、それに限るものではありません。

`1` を送ることで、録音デバイスは録音を開始し、本体 OS に対してデータの転送を開始します。言い換えれば、 `1` を送らずに、fread() をした場合は、fread() でブロックされ続けるということになります。

##### （３）録音データを取得する

``````````cpp
// 録音データの取得
const size_t chunk_size = 48*18; // 48kHz のとき 1 msec 相当 x 18ch
short buf[chunk_size];
while(e_flag_ == 0){
	fread(buf,sizeof(short),chunk_size,stream);
}
``````````

`stream` は、（１）で fopen() したものです。Linux 上での通常のファイルのように、fread() することができます。録音デバイスの録音サンプリングレートは 48kHz、ビット深度 16bit、チャネル数は 18ch となりますので、１回のデータ取得サイズを 48x18 サンプル（ 48x18x2 バイト）とし、fread() しています。

チャンクサイズが大きすぎると、録音サブシステムでのハードウェア的なマイクバッファがオーバーフローしてしまうため、録音データに欠損が生じますので留意してください。

##### （４）録音を終了する

``````````cpp
// 終了
serialPutchar(control, '0'); // 録音終了命令
serialClose(control);
fclose(stream);
``````````

録音終了命令を送り、開いているハンドラを全て閉じます。ここで、録音終了コマンドを送らずにプログラムが終了した場合、録音デバイスは録音をし続けてしまいます。**必ず録音終了コマンドを送らなければならない**ことに留意してください。



